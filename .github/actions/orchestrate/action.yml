name: Orchestrate Playwright Tests
description: Assign tests to shards using historical timing data (storage-agnostic)

inputs:
  test-list:
    description: Path to JSON file with test list (from playwright --list --reporter=json). Generate this in your workflow before calling this action.
    required: true
  timing-file:
    description: Path to timing data JSON file. Required for optimal distribution.
    required: true
  shards:
    description: Total number of shards
    required: true

outputs:
  shard-files:
    description: JSON object with test/file assignments for all shards
    value: ${{ steps.assign.outputs.shard-files }}
  expected-durations:
    description: JSON object with expected durations for all shards
    value: ${{ steps.assign.outputs.expected-durations }}
  total-tests:
    description: Total number of tests/files
    value: ${{ steps.assign.outputs.total-tests }}
  is-optimal:
    description: Whether the distribution is optimal
    value: ${{ steps.assign.outputs.is-optimal }}
  use-orchestrator:
    description: Whether orchestration succeeded (use with get-shard action)
    value: ${{ steps.assign.outputs.use-orchestrator }}

runs:
  using: composite
  steps:
    - name: Assign tests to shards
      id: assign
      shell: bash
      run: |
        TEST_LIST="${{ inputs.test-list }}"
        TIMING_FILE="${{ inputs.timing-file }}"
        TOTAL_SHARDS="${{ inputs.shards }}"

        # Validate test-list exists
        if [ ! -f "$TEST_LIST" ]; then
          echo "::error::test-list file not found: $TEST_LIST"
          echo "::error::Generate it with: npx playwright test --list --reporter=json > test-list.json"
          exit 1
        fi

        # Build command arguments
        CMD_ARGS=(
          --test-list "$TEST_LIST"
          --shards "$TOTAL_SHARDS"
          --output-format json
        )

        # Add timing file if it exists (may not exist on first run)
        if [ -f "$TIMING_FILE" ]; then
          CMD_ARGS+=(--timing-file "$TIMING_FILE")
          echo "Using timing data from $TIMING_FILE"
        else
          echo "::notice::Timing file not found ($TIMING_FILE), using estimation for first run"
        fi

        # Try to run orchestrator
        set +e
        STDERR_FILE=$(mktemp)
        RESULT=$(playwright-orchestrator assign "${CMD_ARGS[@]}" 2>"$STDERR_FILE")
        EXIT_CODE=$?
        STDERR_OUTPUT=$(cat "$STDERR_FILE")
        rm -f "$STDERR_FILE"
        set -e

        # Show any warnings from orchestrator
        if [ -n "$STDERR_OUTPUT" ]; then
          echo "$STDERR_OUTPUT"
        fi

        # Check if orchestrator failed or returned invalid JSON
        if [ $EXIT_CODE -ne 0 ] || ! echo "$RESULT" | jq -e '.' > /dev/null 2>&1; then
          echo "::warning::Orchestrator failed (exit code $EXIT_CODE), falling back to native sharding"
          echo "::warning::Error output: $RESULT $STDERR_OUTPUT"
          
          echo "use-orchestrator=false" >> $GITHUB_OUTPUT
          echo "shard-files={}" >> $GITHUB_OUTPUT
          echo "expected-durations={}" >> $GITHUB_OUTPUT
          echo "total-tests=0" >> $GITHUB_OUTPUT
          echo "is-optimal=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Extract data from result
        IS_OPTIMAL=$(echo "$RESULT" | jq -r ".isOptimal // false")
        TOTAL_TESTS=$(echo "$RESULT" | jq -r ".totalTests // .totalFiles // 0")
        
        echo "use-orchestrator=true" >> $GITHUB_OUTPUT
        echo "shard-files=$(echo "$RESULT" | jq -c '.shards')" >> $GITHUB_OUTPUT
        echo "expected-durations=$(echo "$RESULT" | jq -c '.expectedDurations')" >> $GITHUB_OUTPUT
        echo "total-tests=$TOTAL_TESTS" >> $GITHUB_OUTPUT
        echo "is-optimal=$IS_OPTIMAL" >> $GITHUB_OUTPUT

        # Log summary
        echo "### Orchestrator Assignment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Shard | Tests | Expected Duration |" >> $GITHUB_STEP_SUMMARY
        echo "|-------|-------|-------------------|" >> $GITHUB_STEP_SUMMARY
        for i in $(seq 1 $TOTAL_SHARDS); do
          COUNT=$(echo "$RESULT" | jq -r ".shards.\"$i\" | length")
          DURATION=$(echo "$RESULT" | jq -r ".expectedDurations.\"$i\"")
          DURATION_SEC=$((DURATION / 1000))
          echo "| $i | $COUNT | ${DURATION_SEC}s |" >> $GITHUB_STEP_SUMMARY
        done
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Total**: $TOTAL_TESTS tests, Optimal: $IS_OPTIMAL" >> $GITHUB_STEP_SUMMARY
