name: Get Shard Test Arguments
description: Extract test arguments for a specific shard from orchestrate output

inputs:
  shard-files:
    description: JSON shard assignments from orchestrate action (shard-files output)
    required: true
  test-locations:
    description: JSON test locations (file:line format) from orchestrate action - recommended for exact test filtering
    required: false
    default: ''
  grep-patterns:
    description: JSON grep patterns from orchestrate action (legacy, use test-locations instead)
    required: false
    default: ''
  shard-index:
    description: Which shard to get (1-based)
    required: true
  shards:
    description: Total shard count (for native fallback)
    required: true

outputs:
  test-args:
    description: Arguments for playwright test command (file:line locations, files, or --shard=N/M for fallback)
    value: ${{ steps.parse.outputs.test-args }}
  grep-file:
    description: Path to file containing grep pattern (legacy, only used when test-locations not available)
    value: ${{ steps.parse.outputs.grep-file }}
  has-files:
    description: Whether this shard has orchestrated files
    value: ${{ steps.parse.outputs.has-files }}
  file-list:
    description: Space-separated file list (empty if fallback)
    value: ${{ steps.parse.outputs.file-list }}

runs:
  using: composite
  steps:
    - name: Parse shard assignment
      id: parse
      shell: bash
      run: |
        SHARD_FILES='${{ inputs.shard-files }}'
        TEST_LOCATIONS='${{ inputs.test-locations }}'
        GREP_PATTERNS='${{ inputs.grep-patterns }}'
        SHARD_INDEX='${{ inputs.shard-index }}'
        TOTAL='${{ inputs.shards }}'

        # Check if we have valid shard files
        if [ -z "$SHARD_FILES" ] || [ "$SHARD_FILES" = "{}" ] || [ "$SHARD_FILES" = "null" ]; then
          echo "::notice::No orchestrator data, using native sharding for shard $SHARD_INDEX/$TOTAL"
          echo "test-args=--shard=$SHARD_INDEX/$TOTAL" >> $GITHUB_OUTPUT
          echo "has-files=false" >> $GITHUB_OUTPUT
          echo "file-list=" >> $GITHUB_OUTPUT
          echo "grep-file=" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check if we have grep patterns (preferred - uses full title path for exact matching)
        PATTERN=""
        if [ -n "$GREP_PATTERNS" ] && [ "$GREP_PATTERNS" != "{}" ] && [ "$GREP_PATTERNS" != "null" ]; then
          PATTERN=$(echo "$GREP_PATTERNS" | jq -r ".\"$SHARD_INDEX\" // \"\"")
        fi

        # Check if we have test locations (fallback - doesn't work well for parameterized tests)
        LOCATIONS=""
        if [ -n "$TEST_LOCATIONS" ] && [ "$TEST_LOCATIONS" != "{}" ] && [ "$TEST_LOCATIONS" != "null" ]; then
          LOCATIONS=$(echo "$TEST_LOCATIONS" | jq -r ".\"$SHARD_INDEX\" // [] | join(\" \")")
        fi

        # Extract files/tests for this shard (for logging)
        FILES=$(echo "$SHARD_FILES" | jq -r ".\"$SHARD_INDEX\" // [] | join(\" \")")

        if [ -z "$FILES" ]; then
          echo "::notice::No files assigned to shard $SHARD_INDEX, using native sharding"
          echo "test-args=--shard=$SHARD_INDEX/$TOTAL" >> $GITHUB_OUTPUT
          echo "has-files=false" >> $GITHUB_OUTPUT
          echo "file-list=" >> $GITHUB_OUTPUT
          echo "grep-file=" >> $GITHUB_OUTPUT
        elif [ -n "$PATTERN" ]; then
          # Use grep pattern with full title path for exact test filtering
          FILE_COUNT=$(echo "$SHARD_FILES" | jq -r ".\"$SHARD_INDEX\" | length")
          echo "::notice::Shard $SHARD_INDEX has $FILE_COUNT tests (using grep pattern)"
          
          # Save pattern to file (use absolute path so it works from any working-directory)
          GREP_FILE="$GITHUB_WORKSPACE/playwright-grep-shard-$SHARD_INDEX.txt"
          echo "$PATTERN" > "$GREP_FILE"
          echo "grep-file=$GREP_FILE" >> $GITHUB_OUTPUT
          
          echo "test-args=" >> $GITHUB_OUTPUT
          echo "has-files=true" >> $GITHUB_OUTPUT
          echo "file-list=$FILES" >> $GITHUB_OUTPUT
        elif [ -n "$LOCATIONS" ]; then
          # Fallback: Use test locations (note: doesn't work well for parameterized tests)
          TEST_COUNT=$(echo "$TEST_LOCATIONS" | jq -r ".\"$SHARD_INDEX\" | length")
          echo "::notice::Shard $SHARD_INDEX has $TEST_COUNT tests (using file:line locations)"
          echo "test-args=$LOCATIONS" >> $GITHUB_OUTPUT
          echo "has-files=true" >> $GITHUB_OUTPUT
          echo "file-list=$FILES" >> $GITHUB_OUTPUT
          echo "grep-file=" >> $GITHUB_OUTPUT
        else
          # Use file list for file-level distribution
          FILE_COUNT=$(echo "$SHARD_FILES" | jq -r ".\"$SHARD_INDEX\" | length")
          echo "::notice::Shard $SHARD_INDEX has $FILE_COUNT files"
          echo "test-args=$FILES" >> $GITHUB_OUTPUT
          echo "has-files=true" >> $GITHUB_OUTPUT
          echo "file-list=$FILES" >> $GITHUB_OUTPUT
          echo "grep-file=" >> $GITHUB_OUTPUT
        fi
