name: E2E Monorepo Test

on:
  workflow_dispatch:
  pull_request:
    paths:
      - "src/**"
      - "examples/monorepo/**"
      - ".github/workflows/e2e-monorepo.yml"
      - ".github/actions/**"

env:
  TEST_VERSION: 0.0.0-test.1

jobs:
  # Job 1: Build and create tarball for other jobs
  setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup mise
        uses: jdx/mise-action@v2
        with:
          experimental: true

      - name: Install dependencies
        run: bun install

      - name: Build package
        run: bun run build

      - name: Create tarball
        run: npm pack

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v4
        with:
          name: package-tarball
          path: "*.tgz"
          retention-days: 1

  # Job 2: Orchestrate tests using the real action
  orchestrate:
    needs: [setup]
    runs-on: ubuntu-latest
    outputs:
      test-list-files: ${{ steps.orchestrate.outputs.test-list-files }}
      use-orchestrator: ${{ steps.orchestrate.outputs.use-orchestrator }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: package-tarball

      - name: Install CLI globally from tarball
        run: npm install -g ./nsxbet-playwright-orchestrator-*.tgz

      - name: Install monorepo dependencies
        working-directory: examples/monorepo/apps/web
        run: |
          npm install
          npx playwright install chromium

      - name: Generate test list
        working-directory: examples/monorepo/apps/web
        run: |
          npx playwright test --list --reporter=json > test-list.json
          echo "=== Test list generated ==="
          cat test-list.json | jq -r '.suites[].title' || echo "Could not parse suites"

      # Use the REAL orchestrate action
      - name: Orchestrate tests
        id: orchestrate
        uses: ./.github/actions/orchestrate
        with:
          test-list: examples/monorepo/apps/web/test-list.json
          timing-file: timing-data.json
          shards: 2

      - name: Debug orchestrate output
        run: |
          echo "test-list-files: ${{ steps.orchestrate.outputs.test-list-files }}"
          echo "use-orchestrator: ${{ steps.orchestrate.outputs.use-orchestrator }}"
          echo "total-tests: ${{ steps.orchestrate.outputs.total-tests }}"

      - name: Upload test-list.json for validation
        uses: actions/upload-artifact@v4
        with:
          name: test-list-json
          path: examples/monorepo/apps/web/test-list.json
          retention-days: 1

  # Job 3: Run tests in parallel matrix using real actions
  e2e-tests:
    needs: [setup, orchestrate]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        shardIndex: [1, 2]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: package-tarball

      - name: Install CLI globally from tarball
        run: npm install -g ./nsxbet-playwright-orchestrator-*.tgz

      - name: Install monorepo dependencies
        working-directory: examples/monorepo/apps/web
        run: |
          npm install
          npx playwright install chromium

      # Use the REAL get-shard action
      - name: Get shard assignment
        id: shard
        uses: ./.github/actions/get-shard
        with:
          test-list-files: ${{ needs.orchestrate.outputs.test-list-files }}
          shard-index: ${{ matrix.shardIndex }}
          shards: 2

      - name: Debug shard info
        run: |
          echo "test-list-file: ${{ steps.shard.outputs.test-list-file }}"
          echo "has-tests: ${{ steps.shard.outputs.has-tests }}"
          echo "test-count: ${{ steps.shard.outputs.test-count }}"
          if [ -n "${{ steps.shard.outputs.test-list-file }}" ] && [ -f "${{ steps.shard.outputs.test-list-file }}" ]; then
            echo "=== Test list file contents (first 5 lines) ==="
            head -5 "${{ steps.shard.outputs.test-list-file }}"
          fi

      - name: Download test-list.json for validation
        uses: actions/download-artifact@v4
        with:
          name: test-list-json
          path: examples/monorepo/apps/web

      - name: Run Playwright tests
        id: playwright
        working-directory: examples/monorepo/apps/web
        run: |
          echo "=== Running tests for shard ${{ matrix.shardIndex }} ==="
          TEST_LIST_FILE="${{ steps.shard.outputs.test-list-file }}"
          if [ -n "$TEST_LIST_FILE" ] && [ -f "$TEST_LIST_FILE" ]; then
            npx playwright test --test-list "$TEST_LIST_FILE" 2>&1 | tee /tmp/playwright-output.txt || true
          else
            npx playwright test ${{ steps.shard.outputs.fallback-args }} 2>&1 | tee /tmp/playwright-output.txt || true
          fi
          
          # Extract test counts from Playwright's summary line
          PASSED_COUNT=$(grep -oP '\d+(?= passed)' /tmp/playwright-output.txt | tail -1 || echo "0")
          SKIPPED_COUNT=$(grep -oP '\d+(?= skipped)' /tmp/playwright-output.txt | tail -1 || echo "0")
          TOTAL_COUNT=$((PASSED_COUNT + SKIPPED_COUNT))
          echo "playwright-passed=$PASSED_COUNT" >> $GITHUB_OUTPUT
          echo "playwright-total=$TOTAL_COUNT" >> $GITHUB_OUTPUT
          echo "Extracted from Playwright summary: $PASSED_COUNT passed, $SKIPPED_COUNT skipped ($TOTAL_COUNT total)"

      - name: Validate orchestrator filtering
        run: |
          echo "=== Validating orchestrator filtering ==="
          
          EXPECTED_COUNT="${{ steps.shard.outputs.test-count }}"
          echo "Expected tests for this shard: $EXPECTED_COUNT"
          
          PASSED_COUNT="${{ steps.playwright.outputs.playwright-passed }}"
          TOTAL_COUNT="${{ steps.playwright.outputs.playwright-total }}"
          echo "Playwright reported: $PASSED_COUNT passed, $TOTAL_COUNT total (passed + skipped)"
          
          TOLERANCE=3
          DIFF=$((TOTAL_COUNT - EXPECTED_COUNT))
          ABS_DIFF=${DIFF#-}
          
          if [ "$ABS_DIFF" -gt "$TOLERANCE" ]; then
            echo "::error::TEST COUNT MISMATCH!"
            echo "::error::Expected: $EXPECTED_COUNT tests (from shard assignment)"
            echo "::error::Actual: $TOTAL_COUNT tests (passed + skipped)"
            echo "::error::Difference: $DIFF (tolerance: $TOLERANCE)"
            exit 1
          fi
          
          if [ "$PASSED_COUNT" -lt 5 ]; then
            echo "::error::ORCHESTRATOR FILTERING FAILED! Shard only ran $PASSED_COUNT tests, expected at least 5"
            exit 1
          fi
          
          echo "✓ Orchestrator filtering validated: $TOTAL_COUNT tests visible (expected: $EXPECTED_COUNT, within tolerance: $TOLERANCE)"

      # Upload the raw Playwright JSON report for debugging
      - name: Upload Playwright JSON report
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-results-shard-${{ matrix.shardIndex }}
          path: examples/monorepo/apps/web/playwright-report/results.json
          if-no-files-found: ignore

      # Use the REAL extract-timing action (no shard-file needed — reports are natively clean)
      - name: Extract timing
        if: success() || failure()
        uses: ./.github/actions/extract-timing
        with:
          report-file: examples/monorepo/apps/web/playwright-report/results.json
          output-file: timing-shard-${{ matrix.shardIndex }}.json
          shard: ${{ matrix.shardIndex }}
          project: chromium

      # Validate timing artifact test ID format
      - name: Validate timing artifact test ID format
        if: success() || failure()
        run: |
          echo "=== Validating Timing Artifact Test ID Format ==="
          
          if [ ! -f "timing-shard-${{ matrix.shardIndex }}.json" ]; then
            echo "No timing artifact found, skipping validation"
            exit 0
          fi
          
          echo "Sample test IDs from timing artifact:"
          cat "timing-shard-${{ matrix.shardIndex }}.json" | jq -r '.tests | keys[:5][]' 2>/dev/null || echo "Could not parse"
          echo ""
          
          # Check for ../ path traversal (path mismatch bug)
          PATH_MISMATCH_BUG=$(cat "timing-shard-${{ matrix.shardIndex }}.json" | jq -r '.tests | keys[]' | grep -E '^\.\.' || true)
          
          if [ -n "$PATH_MISMATCH_BUG" ]; then
            echo "::error::BUG DETECTED! Path mismatch causing ../ in test IDs!"
            echo "$PATH_MISMATCH_BUG" | head -5
            exit 1
          fi
          
          # Check for duplicate filename bug
          DUPLICATE_FILENAME_BUG=$(cat "timing-shard-${{ matrix.shardIndex }}.json" | jq -r '.tests | keys[]' | grep -E '\.spec\.(ts|js)::[^:]*\.spec\.(ts|js)::' || true)
          
          if [ -n "$DUPLICATE_FILENAME_BUG" ]; then
            echo "::error::BUG DETECTED! Duplicate filename in test IDs!"
            echo "$DUPLICATE_FILENAME_BUG" | head -5
            exit 1
          fi
          
          echo "✓ No path mismatch or duplicate filename bugs detected in timing artifact"

      # Rename blob report to avoid filename collision during merge
      - name: Rename blob report for unique naming
        if: success() || failure()
        run: |
          BLOB_DIR="examples/monorepo/apps/web/blob-report"
          if [ -d "$BLOB_DIR" ]; then
            cd "$BLOB_DIR"
            for f in *.zip; do
              [ -f "$f" ] && mv "$f" "${f%.zip}-${{ matrix.shardIndex }}.zip"
            done
          else
            echo "No blob-report directory found, skipping rename"
          fi

      - name: Upload blob report
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: blob-report-${{ matrix.shardIndex }}
          path: examples/monorepo/apps/web/blob-report
          retention-days: 1
          compression-level: 0
          if-no-files-found: ignore

      - name: Upload timing artifact
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: timing-shard-${{ matrix.shardIndex }}
          path: timing-shard-${{ matrix.shardIndex }}.json
          if-no-files-found: ignore

  # Job 4: Merge blob reports and validate
  merge-reports:
    needs: [setup, e2e-tests]
    if: ${{ success() || failure() }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: package-tarball

      - name: Install monorepo dependencies (for Playwright merge-reports)
        working-directory: examples/monorepo/apps/web
        run: |
          npm install

      - name: Download blob reports from all shards
        uses: actions/download-artifact@v4
        with:
          path: examples/monorepo/apps/web/all-blob-reports
          pattern: blob-report-*
          merge-multiple: true

      - name: Check for blob reports
        id: check-blobs
        working-directory: examples/monorepo/apps/web
        run: |
          if [ -z "$(ls -A all-blob-reports 2>/dev/null)" ]; then
            echo "::warning::No blob reports found, skipping merge"
            echo "has-blobs=false" >> $GITHUB_OUTPUT
          else
            echo "has-blobs=true" >> $GITHUB_OUTPUT
          fi

      # Merge into HTML report
      - name: Merge into HTML Report
        if: steps.check-blobs.outputs.has-blobs == 'true'
        working-directory: examples/monorepo/apps/web
        run: npx playwright merge-reports --reporter html ./all-blob-reports

      - name: Upload HTML report
        if: steps.check-blobs.outputs.has-blobs == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: html-report
          path: examples/monorepo/apps/web/playwright-report
          retention-days: 1

      # Merge into JSON report — natively clean with --test-list, no filter-report needed
      - name: Merge into JSON Report
        if: steps.check-blobs.outputs.has-blobs == 'true'
        working-directory: examples/monorepo/apps/web
        run: |
          mkdir -p merged-report
          npx playwright merge-reports --reporter json ./all-blob-reports > merged-report/results.json
          echo "Merged report created: $(wc -c < merged-report/results.json) bytes"

      - name: Check merged report for duplicate entries
        if: steps.check-blobs.outputs.has-blobs == 'true'
        working-directory: examples/monorepo/apps/web
        run: |
          echo "=== Checking Merged Report For Duplicates ==="

          TOTAL_SPECS=$(cat merged-report/results.json | jq '
            [.. | .specs? // empty | .[] | .title] | length
          ')

          UNIQUE_SPECS=$(cat merged-report/results.json | jq '
            [.. | .specs? // empty | .[] | .title] | unique | length
          ')

          echo "Total spec entries: $TOTAL_SPECS"
          echo "Unique spec titles: $UNIQUE_SPECS"

          if [ "$TOTAL_SPECS" -gt "$UNIQUE_SPECS" ]; then
            EXTRA=$((TOTAL_SPECS - UNIQUE_SPECS))
            echo "::warning::Merged report has $EXTRA duplicate spec entries"
          else
            echo "✓ No duplicate entries in merged report"
          fi

      - name: Playwright report summary
        if: steps.check-blobs.outputs.has-blobs == 'true'
        uses: nsx-actions/daun_playwright-report-summary@v3
        with:
          report-file: examples/monorepo/apps/web/merged-report/results.json

      - name: Upload merged JSON report
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: merged-report
          path: examples/monorepo/apps/web/merged-report/results.json
          retention-days: 1
          if-no-files-found: ignore

  # Job 5: Merge timing data using the real action
  merge:
    needs: [setup, e2e-tests, merge-reports]
    if: ${{ success() || failure() }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: package-tarball

      - name: Install CLI globally from tarball
        run: npm install -g ./nsxbet-playwright-orchestrator-*.tgz

      - name: Download timing artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: timing-shard-*
          merge-multiple: true

      - name: List timing files
        run: ls -la timing-shard-*.json 2>/dev/null || echo "No timing files found"

      # Use the REAL merge-timing action
      - name: Merge timing
        uses: ./.github/actions/merge-timing
        with:
          new-files: "timing-shard-*.json"
          output-file: playwright-timing.json

      - name: Verify merged timing
        run: |
          if [ -f playwright-timing.json ]; then
            echo "=== Merged timing data ==="
            cat playwright-timing.json | jq '.' | head -100
            
            TEST_COUNT=$(cat playwright-timing.json | jq '.tests | length' 2>/dev/null || echo "0")
            echo ""
            echo "Total tests with timing: $TEST_COUNT"
            
            MIN_EXPECTED_TIMING=40
            if [ "$TEST_COUNT" -lt "$MIN_EXPECTED_TIMING" ]; then
              echo "::error::TIMING MERGE FAILED! Only $TEST_COUNT tests have timing, expected at least $MIN_EXPECTED_TIMING"
              exit 1
            fi
            
            echo "✓ Timing merge validated: $TEST_COUNT tests have timing data"
          else
            echo "::error::No merged timing file created"
            exit 1
          fi

      # Download test-list.json to validate round-trip
      - name: Download test-list.json
        uses: actions/download-artifact@v4
        with:
          name: test-list-json

      # Validate timing data round-trip: extract-timing -> merge -> assign
      - name: Validate timing data round-trip
        run: |
          echo "=== Validating Timing Data Round-Trip ==="
          
          RESULT=$(playwright-orchestrator assign \
            --test-list test-list.json \
            --timing-file playwright-timing.json \
            --shards 2 \
            --output-format json)
          
          echo "=== Assign Output ==="
          echo "$RESULT" | jq '.'
          echo ""
          
          TOTAL_TESTS=$(echo "$RESULT" | jq -r '.totalTests')
          ESTIMATED_COUNT=$(echo "$RESULT" | jq -r '.estimatedTests | length')
          IS_OPTIMAL=$(echo "$RESULT" | jq -r '.isOptimal')
          
          echo "Total tests discovered: $TOTAL_TESTS"
          echo "Tests with estimated duration (no timing match): $ESTIMATED_COUNT"
          echo "Optimal solution: $IS_OPTIMAL"
          
          TIMING_TEST_COUNT=$(cat playwright-timing.json | jq '.tests | length')
          echo "Timing data has $TIMING_TEST_COUNT test entries"
          
          if [ "$TIMING_TEST_COUNT" -gt 0 ] && [ "$ESTIMATED_COUNT" -eq "$TOTAL_TESTS" ]; then
            echo "::error::TIMING DATA NOT BEING USED!"
            echo "::error::Timing file has $TIMING_TEST_COUNT entries but ALL $TOTAL_TESTS tests are estimated"
            echo "Sample test IDs from timing file:"
            cat playwright-timing.json | jq -r '.tests | keys[:5][]'
            echo "Sample test IDs from assign (discovered):"
            echo "$RESULT" | jq -r '.shards["1"][:5][]'
            exit 1
          fi
          
          ESTIMATED_PCT=$((ESTIMATED_COUNT * 100 / TOTAL_TESTS))
          MAX_ESTIMATED_PCT=20
          
          if [ "$ESTIMATED_PCT" -gt "$MAX_ESTIMATED_PCT" ]; then
            echo "::warning::High ratio of estimated tests: ${ESTIMATED_PCT}%"
            echo "Estimated tests (no timing match):"
            echo "$RESULT" | jq -r '.estimatedTests[:10][]'
          fi
          
          echo ""
          echo "✓ Timing data round-trip validated!"
          echo "  - $((TOTAL_TESTS - ESTIMATED_COUNT)) tests matched timing data"
          echo "  - $ESTIMATED_COUNT tests estimated (new or ID mismatch)"
