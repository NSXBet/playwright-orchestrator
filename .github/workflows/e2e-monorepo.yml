name: E2E Monorepo Test

on:
  workflow_dispatch:
  pull_request:
    paths:
      - "src/**"
      - "examples/monorepo/**"
      - ".github/workflows/e2e-monorepo.yml"
      - ".github/actions/**"

env:
  TEST_VERSION: 0.0.0-test.1

jobs:
  # Job 1: Build and create tarball for other jobs
  setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup mise
        uses: jdx/mise-action@v2
        with:
          experimental: true

      - name: Install dependencies
        run: bun install

      - name: Build package
        run: bun run build

      - name: Create tarball
        run: npm pack

      - name: Upload tarball artifact
        uses: actions/upload-artifact@v4
        with:
          name: package-tarball
          path: "*.tgz"
          retention-days: 1

  # Job 2: Orchestrate tests using the real action
  orchestrate:
    needs: [setup]
    runs-on: ubuntu-latest
    outputs:
      shard-files: ${{ steps.orchestrate.outputs.shard-files }}
      use-orchestrator: ${{ steps.orchestrate.outputs.use-orchestrator }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: package-tarball

      - name: Install CLI globally from tarball
        run: npm install -g ./nsxbet-playwright-orchestrator-*.tgz

      - name: Install monorepo dependencies
        working-directory: examples/monorepo/apps/web
        run: |
          # Copy tarball to install as dev dependency for fixture
          cp $GITHUB_WORKSPACE/nsxbet-playwright-orchestrator-*.tgz .
          # Install deps first, then override orchestrator with local tarball
          npm install
          npm install ./nsxbet-playwright-orchestrator-*.tgz
          npx playwright install chromium

      - name: Generate test list
        working-directory: examples/monorepo/apps/web
        run: |
          npx playwright test --list --reporter=json > test-list.json
          echo "=== Test list generated ==="
          cat test-list.json | jq -r '.suites[].title' || echo "Could not parse suites"

      # Use the REAL orchestrate action
      - name: Orchestrate tests
        id: orchestrate
        uses: ./.github/actions/orchestrate
        with:
          test-list: examples/monorepo/apps/web/test-list.json
          timing-file: timing-data.json
          shards: 2
          level: test

      - name: Debug orchestrate output
        run: |
          echo "shard-files: ${{ steps.orchestrate.outputs.shard-files }}"
          echo "use-orchestrator: ${{ steps.orchestrate.outputs.use-orchestrator }}"
          echo "total-tests: ${{ steps.orchestrate.outputs.total-tests }}"

      - name: Upload test-list.json for validation
        uses: actions/upload-artifact@v4
        with:
          name: test-list-json
          path: examples/monorepo/apps/web/test-list.json
          retention-days: 1

  # Job 3: Run tests in parallel matrix using real actions
  e2e-tests:
    needs: [setup, orchestrate]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        shardIndex: [1, 2]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: package-tarball

      - name: Install CLI globally from tarball
        run: npm install -g ./nsxbet-playwright-orchestrator-*.tgz

      - name: Install monorepo dependencies
        working-directory: examples/monorepo/apps/web
        run: |
          # Copy tarball to install as dev dependency for fixture
          cp $GITHUB_WORKSPACE/nsxbet-playwright-orchestrator-*.tgz .
          # Install deps first, then override orchestrator with local tarball
          npm install
          npm install ./nsxbet-playwright-orchestrator-*.tgz
          npx playwright install chromium

      # Use the REAL get-shard action
      - name: Get shard assignment
        id: shard
        uses: ./.github/actions/get-shard
        with:
          shard-files: ${{ needs.orchestrate.outputs.shard-files }}
          shard-index: ${{ matrix.shardIndex }}
          shards: 2

      - name: Debug shard info
        run: |
          echo "shard-file: ${{ steps.shard.outputs.shard-file }}"
          echo "has-tests: ${{ steps.shard.outputs.has-tests }}"
          echo "test-count: ${{ steps.shard.outputs.test-count }}"
          if [ -n "${{ steps.shard.outputs.shard-file }}" ] && [ -f "${{ steps.shard.outputs.shard-file }}" ]; then
            echo "=== Shard file contents (discovery test IDs) ==="
            cat "${{ steps.shard.outputs.shard-file }}" | jq -r '.[:5][]' 2>/dev/null || cat "${{ steps.shard.outputs.shard-file }}"
            echo ""
            echo "=== Test ID Format Analysis ==="
            SAMPLE_ID=$(cat "${{ steps.shard.outputs.shard-file }}" | jq -r '.[0]' 2>/dev/null || echo "")
            echo "Sample: $SAMPLE_ID"
            echo "Parts: $(echo "$SAMPLE_ID" | tr '::' '\n' | head -5)"
          fi

      - name: Download test-list.json for validation
        uses: actions/download-artifact@v4
        with:
          name: test-list-json
          path: examples/monorepo/apps/web

      # CRITICAL: Validate test ID consistency BEFORE running tests
      # This catches the rootDir vs testDir mismatch bug
      - name: Validate test ID consistency
        working-directory: examples/monorepo/apps/web
        run: |
          echo "=== Validating Test ID Consistency ==="
          echo ""
          echo "This step checks that discovery and fixture generate IDENTICAL test IDs."
          echo "If they differ, tests will silently fail to match and run incorrectly."
          echo ""
          
          # Get paths from Playwright config via test-list.json
          ROOT_DIR=$(cat test-list.json | jq -r '.config.rootDir // empty')
          TEST_DIR=$(cat test-list.json | jq -r '.config.projects[0].testDir // empty')
          
          echo "From test-list.json:"
          echo "  config.rootDir: $ROOT_DIR"
          echo "  projects[0].testDir: $TEST_DIR"
          echo ""
          
          if [ -z "$ROOT_DIR" ] || [ -z "$TEST_DIR" ]; then
            echo "::error::Could not extract rootDir or testDir from test-list.json"
            exit 1
          fi
          
          # Check if testDir is a subdirectory of rootDir (the problematic case)
          if [[ "$TEST_DIR" == "$ROOT_DIR"* ]] && [ "$TEST_DIR" != "$ROOT_DIR" ]; then
            # testDir is a subdirectory - this is the bet-app scenario
            RELATIVE_TEST_DIR="${TEST_DIR#$ROOT_DIR/}"
            echo "⚠️  testDir is a subdirectory of rootDir!"
            echo "  Relative path: $RELATIVE_TEST_DIR"
            echo ""
            
            # Get a sample test ID from the shard file
            SHARD_FILE="${{ steps.shard.outputs.shard-file }}"
            if [ -f "$SHARD_FILE" ]; then
              SAMPLE_ID=$(cat "$SHARD_FILE" | jq -r '.[0] // empty')
              echo "Sample test ID from shard file (discovery):"
              echo "  $SAMPLE_ID"
              echo ""
              
              # Extract the file path from the test ID (before first ::)
              FILE_PATH=$(echo "$SAMPLE_ID" | cut -d':' -f1)
              echo "File path in test ID: $FILE_PATH"
              
              # Check if the file path starts with the relative testDir path
              # If discovery uses rootDir, paths will be like: src/test/e2e/file.spec.ts
              # If fixture uses testDir, paths will be like: file.spec.ts
              if [[ "$FILE_PATH" == "$RELATIVE_TEST_DIR"* ]]; then
                echo ""
                echo "::error::BUG DETECTED! Test IDs have inconsistent paths!"
                echo "::error::Discovery generated: $FILE_PATH (relative to rootDir)"
                echo "::error::Fixture would generate: ${FILE_PATH#$RELATIVE_TEST_DIR/} (relative to testDir)"
                echo "::error::These don't match, causing tests to skip incorrectly!"
                echo ""
                echo "This is the rootDir vs testDir mismatch bug."
                echo "Discovery uses config.rootDir but fixture uses project.testDir."
                exit 1
              else
                echo "✓ Test IDs appear to be relative to testDir correctly"
              fi
            else
              echo "No shard file to validate"
            fi
          else
            echo "✓ testDir equals rootDir - no path mismatch possible"
          fi

      - name: Run Playwright tests
        id: playwright
        working-directory: examples/monorepo/apps/web
        env:
          ORCHESTRATOR_SHARD_FILE: ${{ steps.shard.outputs.shard-file }}
          ORCHESTRATOR_DEBUG: "1"
          CI: "true"
        run: |
          echo "=== Running tests for shard ${{ matrix.shardIndex }} ==="
          # Capture output for validation - Playwright outputs summary line like "22 passed, 2 skipped"
          npx playwright test 2>&1 | tee /tmp/playwright-output.txt || true
          
          # Extract passed count from Playwright's summary line (most reliable source)
          PASSED_COUNT=$(grep -oP '\d+(?= passed)' /tmp/playwright-output.txt | tail -1 || echo "0")
          echo "playwright-passed=$PASSED_COUNT" >> $GITHUB_OUTPUT
          echo "Extracted from Playwright summary: $PASSED_COUNT passed"

      - name: Validate orchestrator filtering
        run: |
          # This step MUST FAIL if orchestrator is not filtering correctly
          echo "=== Validating orchestrator filtering ==="
          
          # Get expected test count from shard assignment
          EXPECTED_COUNT="${{ steps.shard.outputs.test-count }}"
          echo "Expected tests for this shard: $EXPECTED_COUNT"
          
          # Use Playwright's own reported count (most reliable - avoids jq parsing issues)
          PASSED_COUNT="${{ steps.playwright.outputs.playwright-passed }}"
          echo "Playwright reported passed: $PASSED_COUNT"
          
          # STRICT VALIDATION: Passed count should match expected count exactly
          # Allow small margin for skipped tests within the shard (e.g., test.skip())
          TOLERANCE=3
          DIFF=$((PASSED_COUNT - EXPECTED_COUNT))
          ABS_DIFF=${DIFF#-}  # Absolute value
          
          if [ "$ABS_DIFF" -gt "$TOLERANCE" ]; then
            echo "::error::TEST COUNT MISMATCH!"
            echo "::error::Expected: $EXPECTED_COUNT tests (from shard assignment)"
            echo "::error::Actual: $PASSED_COUNT tests passed"
            echo "::error::Difference: $DIFF (tolerance: $TOLERANCE)"
            echo ""
            echo "This indicates one of:"
            echo "  1. Test ID mismatch between discovery and fixture (rootDir vs testDir bug)"
            echo "  2. Shard file not being loaded correctly"
            echo "  3. Tests being filtered incorrectly"
            exit 1
          fi
          
          # CRITICAL ASSERTION: Shard should run at least some tests
          if [ "$PASSED_COUNT" -lt 5 ]; then
            echo "::error::ORCHESTRATOR FILTERING FAILED! Shard only ran $PASSED_COUNT tests, expected at least 5"
            echo "::error::This means orchestrator may be filtering TOO aggressively or test IDs don't match"
            exit 1
          fi
          
          echo "✓ Orchestrator filtering validated: $PASSED_COUNT tests executed (expected: $EXPECTED_COUNT, within tolerance: $TOLERANCE)"

      # Upload the raw Playwright JSON report for debugging
      - name: Upload Playwright JSON report
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-results-shard-${{ matrix.shardIndex }}
          path: examples/monorepo/apps/web/test-results/results.json
          if-no-files-found: ignore

      # Use the REAL extract-timing action
      - name: Extract timing
        if: success() || failure()
        uses: ./.github/actions/extract-timing
        with:
          report-file: examples/monorepo/apps/web/test-results/results.json
          output-file: timing-shard-${{ matrix.shardIndex }}.json
          shard: ${{ matrix.shardIndex }}

      # CRITICAL: Validate timing artifact test ID format
      # This catches the bug where:
      # 1. Path mismatch causes ../../../ in test IDs
      # 2. Root suite title (filename) is included in test IDs
      - name: Validate timing artifact test ID format
        if: success() || failure()
        run: |
          echo "=== Validating Timing Artifact Test ID Format ==="
          
          if [ ! -f "timing-shard-${{ matrix.shardIndex }}.json" ]; then
            echo "No timing artifact found, skipping validation"
            exit 0
          fi
          
          # Extract all test IDs from the timing artifact
          echo "Sample test IDs from timing artifact:"
          cat "timing-shard-${{ matrix.shardIndex }}.json" | jq -r '.tests | keys[:5][]' 2>/dev/null || echo "Could not parse"
          echo ""
          
          # BUG 1: Check for ../ path traversal (path mismatch bug)
          # Bug produces: ../../../file.spec.ts::...
          # Correct is:   file.spec.ts::... or subdir/file.spec.ts::...
          PATH_MISMATCH_BUG=$(cat "timing-shard-${{ matrix.shardIndex }}.json" | jq -r '.tests | keys[]' | grep -E '^\.\.' || true)
          
          if [ -n "$PATH_MISMATCH_BUG" ]; then
            echo "::error::BUG DETECTED! Path mismatch causing ../ in test IDs!"
            echo "::error::testDir and suite.file paths are resolved from different bases"
            echo ""
            echo "Examples of buggy test IDs with path mismatch:"
            echo "$PATH_MISMATCH_BUG" | head -5
            echo ""
            echo "Expected format: file.spec.ts::Describe::test"
            echo "Actual format:   ../../../file.spec.ts::..."
            exit 1
          fi
          
          # BUG 2: Check for duplicate filename bug
          # Bug produces: file.spec.ts::file.spec.ts::Describe::test
          # Pattern: look for .spec.ts or .spec.js appearing twice after first ::
          DUPLICATE_FILENAME_BUG=$(cat "timing-shard-${{ matrix.shardIndex }}.json" | jq -r '.tests | keys[]' | grep -E '\.spec\.(ts|js)::[^:]*\.spec\.(ts|js)::' || true)
          
          if [ -n "$DUPLICATE_FILENAME_BUG" ]; then
            echo "::error::BUG DETECTED! Duplicate filename in test IDs!"
            echo "::error::Root suite title (filename) is being included in titlePath"
            echo ""
            echo "Examples of buggy test IDs with duplicate filename:"
            echo "$DUPLICATE_FILENAME_BUG" | head -5
            echo ""
            echo "Expected format: file.spec.ts::Describe::test"
            echo "Actual format:   file.spec.ts::file.spec.ts::Describe::test"
            exit 1
          fi
          
          echo "✓ No path mismatch or duplicate filename bugs detected in timing artifact"

      - name: Upload timing artifact
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: timing-shard-${{ matrix.shardIndex }}
          path: timing-shard-${{ matrix.shardIndex }}.json
          if-no-files-found: ignore

  # Job 4: Merge timing data using the real action
  merge:
    needs: [setup, e2e-tests]
    if: success() || failure()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: package-tarball

      - name: Install CLI globally from tarball
        run: npm install -g ./nsxbet-playwright-orchestrator-*.tgz

      - name: Download timing artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: timing-shard-*
          merge-multiple: true

      - name: List timing files
        run: ls -la timing-shard-*.json 2>/dev/null || echo "No timing files found"

      # Use the REAL merge-timing action
      - name: Merge timing
        uses: ./.github/actions/merge-timing
        with:
          new-files: "timing-shard-*.json"
          output-file: playwright-timing.json

      - name: Verify merged timing
        run: |
          if [ -f playwright-timing.json ]; then
            echo "=== Merged timing data ==="
            cat playwright-timing.json | jq '.' | head -100
            
            TEST_COUNT=$(cat playwright-timing.json | jq '.tests | length' 2>/dev/null || echo "0")
            echo ""
            echo "Total tests with timing: $TEST_COUNT"
            
            # CRITICAL ASSERTION: All shards combined should have timing for most tests
            # We expect ~49 tests total, timing should capture at least 40
            MIN_EXPECTED_TIMING=40
            if [ "$TEST_COUNT" -lt "$MIN_EXPECTED_TIMING" ]; then
              echo "::error::TIMING MERGE FAILED! Only $TEST_COUNT tests have timing, expected at least $MIN_EXPECTED_TIMING"
              echo "::error::This suggests some shards didn't report timing correctly"
              exit 1
            fi
            
            echo "✓ Timing merge validated: $TEST_COUNT tests have timing data"
          else
            echo "::error::No merged timing file created"
            exit 1
          fi

      # Download test-list.json to validate round-trip
      - name: Download test-list.json
        uses: actions/download-artifact@v4
        with:
          name: test-list-json

      # CRITICAL: Validate that timing data can be USED by orchestrator
      # This is the round-trip test: extract-timing -> merge -> assign
      # If test IDs don't match, all tests will be "estimated" (no timing match)
      - name: Validate timing data round-trip
        run: |
          echo "=== Validating Timing Data Round-Trip ==="
          echo ""
          echo "This validates that timing data generated by extract-timing"
          echo "can be correctly matched by the assign command."
          echo "If test IDs are inconsistent, timing won't be used!"
          echo ""
          
          # Run assign with the merged timing data
          RESULT=$(playwright-orchestrator assign \
            --test-list test-list.json \
            --timing-file playwright-timing.json \
            --shards 2 \
            --level test \
            --output-format json)
          
          echo "=== Assign Output ==="
          echo "$RESULT" | jq '.'
          echo ""
          
          # Extract key metrics
          TOTAL_TESTS=$(echo "$RESULT" | jq -r '.totalTests')
          ESTIMATED_COUNT=$(echo "$RESULT" | jq -r '.estimatedTests | length')
          IS_OPTIMAL=$(echo "$RESULT" | jq -r '.isOptimal')
          
          echo "Total tests discovered: $TOTAL_TESTS"
          echo "Tests with estimated duration (no timing match): $ESTIMATED_COUNT"
          echo "Optimal solution: $IS_OPTIMAL"
          echo ""
          
          # CRITICAL: If timing exists but all tests are "estimated", IDs don't match!
          TIMING_TEST_COUNT=$(cat playwright-timing.json | jq '.tests | length')
          echo "Timing data has $TIMING_TEST_COUNT test entries"
          
          if [ "$TIMING_TEST_COUNT" -gt 0 ] && [ "$ESTIMATED_COUNT" -eq "$TOTAL_TESTS" ]; then
            echo "::error::TIMING DATA NOT BEING USED!"
            echo "::error::Timing file has $TIMING_TEST_COUNT entries but ALL $TOTAL_TESTS tests are estimated"
            echo "::error::This means test IDs from extract-timing don't match test IDs from discovery"
            echo ""
            echo "Sample test IDs from timing file:"
            cat playwright-timing.json | jq -r '.tests | keys[:5][]'
            echo ""
            echo "Sample test IDs from assign (discovered):"
            echo "$RESULT" | jq -r '.shards["1"][:5][]'
            exit 1
          fi
          
          # Allow some estimated tests (new tests without history) but most should have timing
          MAX_ESTIMATED_RATIO=0.2  # Allow up to 20% estimated
          ESTIMATED_RATIO=$(echo "scale=2; $ESTIMATED_COUNT / $TOTAL_TESTS" | bc)
          
          echo "Estimated ratio: $ESTIMATED_RATIO (max allowed: $MAX_ESTIMATED_RATIO)"
          
          # Use integer comparison (multiply by 100)
          ESTIMATED_PCT=$((ESTIMATED_COUNT * 100 / TOTAL_TESTS))
          MAX_ESTIMATED_PCT=20
          
          if [ "$ESTIMATED_PCT" -gt "$MAX_ESTIMATED_PCT" ]; then
            echo "::warning::High ratio of estimated tests: ${ESTIMATED_PCT}%"
            echo "::warning::This suggests some test IDs don't match between extract-timing and discovery"
            echo ""
            echo "Estimated tests (no timing match):"
            echo "$RESULT" | jq -r '.estimatedTests[:10][]'
            # Don't fail, just warn - some drift is expected
          fi
          
          echo ""
          echo "✓ Timing data round-trip validated!"
          echo "  - $((TOTAL_TESTS - ESTIMATED_COUNT)) tests matched timing data"
          echo "  - $ESTIMATED_COUNT tests estimated (new or ID mismatch)"
