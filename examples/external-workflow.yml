# Example workflow for external repositories
# Copy this to your repository's .github/workflows/ directory
#
# This workflow uses a three-phase pattern:
# 1. orchestrate: Run once, compute shard assignments for all shards
# 2. e2e: Matrix jobs use get-shard action to get their shard file
# 3. merge-timing: Collect timing data from all shards
#
# YOU control: cache keys, artifact paths
# ACTIONS handle: orchestration logic, parsing, fallback

name: E2E Tests with Orchestrator

on:
  push:
    branches: [main]
  pull_request:

env:
  SHARDS: 4

jobs:
  # ============================================
  # Phase 1: Orchestrate (runs once)
  # ============================================
  orchestrate:
    name: Orchestrate
    runs-on: ubuntu-24.04
    timeout-minutes: 10
    outputs:
      shard-files: ${{ steps.orchestrate.outputs.shard-files }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Setup Orchestrator
        uses: NSXBet/playwright-orchestrator/.github/actions/setup-orchestrator@v0

      # YOU control cache location
      - name: Restore timing cache
        uses: actions/cache/restore@v4
        with:
          path: timing-data.json
          key: playwright-timing-${{ github.ref_name }}
          restore-keys: |
            playwright-timing-main
            playwright-timing-

      # IMPORTANT: Use Playwright to list tests for accurate discovery
      # This ensures parameterized tests (test.each) are correctly identified
      - name: Generate test list
        run: npx playwright test --list --reporter=json > test-list.json

      # Action handles all orchestration logic
      - name: Orchestrate tests
        id: orchestrate
        uses: NSXBet/playwright-orchestrator/.github/actions/orchestrate@v0
        with:
          test-list: test-list.json  # Use pre-generated list (recommended)
          shards: ${{ env.SHARDS }}
          timing-file: timing-data.json

  # ============================================
  # Phase 2: Run tests (parallel matrix)
  # ============================================
  e2e:
    name: E2E Shard ${{ matrix.shard }}
    needs: [orchestrate]
    runs-on: ubuntu-24.04
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3, 4]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Setup your project (adjust as needed)
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install chromium --with-deps

      # Action outputs shard-file for reporter-based filtering
      - name: Get shard assignment
        uses: NSXBet/playwright-orchestrator/.github/actions/get-shard@v0
        id: shard
        with:
          shard-files: ${{ needs.orchestrate.outputs.shard-files }}
          shard-index: ${{ matrix.shard }}
          shards: ${{ env.SHARDS }}

      # Reporter reads ORCHESTRATOR_SHARD_FILE to filter tests
      # Falls back to native --shard=N/M if orchestration failed
      - name: Run Playwright tests
        run: npx playwright test ${{ steps.shard.outputs.fallback-args }}
        env:
          ORCHESTRATOR_SHARD_FILE: ${{ steps.shard.outputs.shard-file }}

      # Extract timing (runs unless cancelled)
      - name: Setup Orchestrator
        if: success() || failure()
        uses: NSXBet/playwright-orchestrator/.github/actions/setup-orchestrator@v0

      - name: Extract timing
        if: success() || failure()
        uses: NSXBet/playwright-orchestrator/.github/actions/extract-timing@v0
        with:
          report-file: playwright-report/results.json  # Adjust to your report path
          output-file: timing-shard-${{ matrix.shard }}.json
          shard: ${{ matrix.shard }}

      # YOU control artifact location
      - name: Upload timing artifact
        if: success() || failure()
        uses: actions/upload-artifact@v4
        with:
          name: timing-shard-${{ matrix.shard }}
          path: timing-shard-${{ matrix.shard }}.json
          retention-days: 1
          if-no-files-found: ignore

      # Upload Playwright report on failure (optional)
      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report-${{ matrix.shard }}
          path: playwright-report/
          retention-days: 7

  # ============================================
  # Phase 3: Merge timing data
  # ============================================
  merge-timing:
    name: Merge Timing Data
    needs: [orchestrate, e2e]
    if: success() || failure()
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Orchestrator
        uses: NSXBet/playwright-orchestrator/.github/actions/setup-orchestrator@v0

      # YOU control cache location
      - name: Restore timing cache
        uses: actions/cache/restore@v4
        with:
          path: timing-data.json
          key: playwright-timing-${{ github.ref_name }}
          restore-keys: playwright-timing-

      # YOU control artifact location
      - name: Download timing artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: timing-shard-*
          merge-multiple: true

      - name: Merge timing data
        uses: NSXBet/playwright-orchestrator/.github/actions/merge-timing@v0
        with:
          existing-file: timing-data.json
          new-files: timing-shard-*.json
          output-file: timing-data.json

      # YOU control cache location
      - name: Save timing cache
        uses: actions/cache/save@v4
        with:
          path: timing-data.json
          key: playwright-timing-${{ github.ref_name }}-${{ github.run_id }}

      # Show timing stats (optional)
      - name: Show timing stats
        run: |
          echo "=== Timing Data Stats ==="
          if [ -f timing-data.json ]; then
            jq '{
              version: .version,
              updatedAt: .updatedAt,
              testCount: (.tests | length)
            }' timing-data.json
          else
            echo "No timing data file found"
          fi
